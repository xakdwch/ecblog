(window.webpackJsonp=window.webpackJsonp||[]).push([[15],{289:function(t,s,a){"use strict";a.r(s);var e=a(14),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"过滤规则"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#过滤规则"}},[t._v("#")]),t._v(" 过滤规则")]),t._v(" "),a("p"),a("div",{staticClass:"table-of-contents"},[a("ul",[a("li",[a("a",{attrs:{href:"#背景"}},[t._v("背景")])]),a("li",[a("a",{attrs:{href:"#规则简介"}},[t._v("规则简介")])])])]),a("p"),t._v(" "),a("h2",{attrs:{id:"背景"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#背景"}},[t._v("#")]),t._v(" 背景")]),t._v(" "),a("p",[t._v("etcd的原始接口只能按照Key的前缀来批量同步数据，源集群中指定前缀下的所有数据都将被同步到目的集群。然而在某些场景下，我们期望有更细粒度的规则来精准地同步数据。我们可以通过配置Etcd-Carry过滤规则来达到这样的效果💯。")]),t._v(" "),a("div",{staticClass:"custom-block tip"},[a("p",{staticClass:"custom-block-title"},[t._v("提示")]),t._v(" "),a("p",[t._v("当前过滤规则主要适用于过滤etcd中的Kubernetes数据。")])]),t._v(" "),a("h2",{attrs:{id:"规则简介"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#规则简介"}},[t._v("#")]),t._v(" 规则简介")]),t._v(" "),a("p",[t._v("xx")])])}),[],!1,null,null,null);s.default=r.exports}}]);